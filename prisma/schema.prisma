generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Rule {
  rule_id          Int    @id @default(autoincrement())
  rule_name        String
  rule_description String
  users            User[]
  rule_created_at  DateTime @default(now())
  rule_updated_at  DateTime @default(now())
}

model User {
  user_id         Int              @id @default(autoincrement())
  name            String?
  email           String           @unique @db.VarChar(255)
  emailVerified   DateTime?
  image           String?
  password        String
  role_id         Int
  role            Rule             @relation(fields: [role_id], references: [rule_id])
  phone_number    String           @db.VarChar(20)
  events          Events[]
  tickets         Tickets[]
  transactions    Transactions[]
  accounts        Account[]
  sessions        Session[]
  authenticators  Authenticator[]
  created_at      DateTime          @default(now())
  updated_at      DateTime          @updatedAt
}

model Account {
  userId            Int
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  created_at        DateTime        @default(now())
  updated_at        DateTime        @updatedAt
  user              User            @relation(fields: [userId], references: [user_id], onDelete: Cascade)
  @@id([provider, providerAccountId])
}

model Session {
  sessionToken String   @unique
  userId       Int
  expires      DateTime
  user         User     @relation(fields: [userId], references: [user_id], onDelete: Cascade)
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime
  @@id([identifier, token])
}

model Authenticator {
  credentialID         String  @unique
  userId               Int
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  user                 User    @relation(fields: [userId], references: [user_id], onDelete: Cascade)
  @@id([userId, credentialID])
}

model Categories {
  category_id          Int      @id @default(autoincrement())
  category_name        String
  category_description String
  events               Events[]
  created_at           DateTime @default(now())
  updated_at           DateTime @default(now())
}

model Events {
  event_id            Int                  @id @default(autoincrement())
  title               String
  description         String
  start_date          DateTime
  end_date            DateTime
  start_hours         DateTime
  Lieu                String
  banner_image        String
  entrer              String
  images              String[]
  priority            Boolean
  organizer_id        Int
  organizer           User                 @relation(fields: [organizer_id], references: [user_id])
  category_id         Int
  category            Categories           @relation(fields: [category_id], references: [category_id])
  ticket_price        Float
  vedette             Boolean
  tickets             Tickets[]
  marketing_campaigns Marketing_Campaigns[]
  visibility          EventVisibility
  created_at          DateTime             @default(now())
  updated_at          DateTime             @default(now())
}

model Tickets {
  ticket_id    Int           @id @default(autoincrement())
  event_id     Int
  event        Events        @relation(fields: [event_id], references: [event_id])
  user_id      Int
  user         User          @relation(fields: [user_id], references: [user_id])
  payment      Payments[]

  price        Float         // Prix du ticket
  ticket_type  String        // Type de ticket (VIP, Standard, etc.)
  status       TicketStatus  // Statut du ticket (Valide, Utilisé, Annulé)

  qr_code      String        @unique  // QR code unique du ticket
  token        String        @unique  // Token sécurisé pour éviter la fraude
  is_used      Boolean       @default(false) // Vérifie si le ticket a déjà été scanné
  ticket_entrie Ticket_Entries[]
  created_at   DateTime      @default(now())
  updated_at   DateTime      @updatedAt
}

model Ticket_Entries {
  entry_id   Int     @id @default(autoincrement())
  ticket_id  Int     @unique // Empêche plusieurs entrées avec le même ticket
  scanned_at DateTime @default(now())
  ticket     Tickets @relation(fields: [ticket_id], references: [ticket_id])
}

model Marketing_Campaigns {
  campaign_id  Int           @id @default(autoincrement())
  event_id     Int
  event        Events        @relation(fields: [event_id], references: [event_id])
  start_date   DateTime
  end_date     DateTime
  type         String
  status       String
  created_at   DateTime      @default(now())
  updated_at   DateTime      @default(now())
}

model Transactions {
  transaction_id  Int           @id @default(autoincrement())
  user_id         Int
  user            User          @relation(fields: [user_id], references: [user_id])
  amount          Float
  payment_method  String
  status          PaymentStatus
  payment         Payments[]
  created_at      DateTime      @default(now())
  updated_at      DateTime      @default(now())
}

model Payments {
  payment_id      Int           @id @default(autoincrement())
  ticket_id       Int
  ticket          Tickets       @relation(fields: [ticket_id], references: [ticket_id])
  transaction_id  Int
  transaction     Transactions  @relation(fields: [transaction_id], references: [transaction_id])
  amount          Float
  payment_status  PaymentStatus
  payment_method  String
  created_at      DateTime      @default(now())
}

model Guide {
  guide_id    Int      @id @default(autoincrement())
  title       String
  description String
  file_url    String
  created_at  DateTime @default(now())
}

model Faqs {
  faq_id      Int      @id @default(autoincrement())
  question    String
  answer      String
  created_at  DateTime @default(now())
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum TicketStatus {
  ACTIVE
  USED
  CANCELLED
  EXPIRED
}

enum EventVisibility {
  PUBLIC
  PRIVATE
  DRAFT
}